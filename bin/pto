#!/usr/bin/env python3

import argparse
import calendar
import collections
import datetime
import itertools
from typing import List
from dateutil import relativedelta, rrule

weekdays = list(calendar.day_name)
InnerAccumulated = collections.namedtuple("InnerAccumulated", ["date", "running_hours"])

def accumulate_pto(args, datetimes: List[datetime.datetime]):
    """
    Calculates the number of accumulated hours of PTO for the given dates.

    Args:
        args: The command-line arguments.
        datetimes: A list of datetimes for which to calculate the number of accumulated hours.
    """

    def f(current: InnerAccumulated, next_date: datetime.date) -> InnerAccumulated:
        """Calculate the number of accumulated hours for the given date."""
        return InnerAccumulated(next_date, current.running_hours + args.rate)

    dates = map(lambda d: d.date(), datetimes)
    accumulated = itertools.chain([InnerAccumulated(args.today, args.current_hours)], dates)
    accumulated = itertools.accumulate(accumulated, f)
    accumulated = list(accumulated)
    if args.verbose:
        print("Dates:")
        for i, inner_accumulated in enumerate(accumulated):
            d = inner_accumulated.date
            h = inner_accumulated.running_hours
            print(f"\t{i:03d}: {d} ({d:%A}): ", end="")

            if args.days:
                print(f"{h / 8:.02f} days")
            else:
                print(f"{h:.02f} hours")

        print()

    return accumulated[-1].running_hours

def get_biweekly_rrule(args):
    """Create a recurrence rule for two-week pay periods between args.today and args.date, starting on args.previous_period."""
    # every 2 weeks
    dates = rrule.rrule(rrule.WEEKLY, interval=2, dtstart=args.previous_period, until=args.date)

    return dates

def get_bimonthly_rrule(args):
    """Create a recurrence rule for pay periods between args.today and args.date, starting on args.previous_period, where a period is the 15th and last day of the month."""
    dates = rrule.rruleset()

    # 15th of the month, if it's a weekday
    dates.rrule(rrule.rrule(rrule.MONTHLY, bymonthday=15, byweekday=(rrule.MO, rrule.TU, rrule.WE, rrule.TH, rrule.FR),
        dtstart=args.previous_period, until=args.date))

    # the Friday before the 15th, if the 15th is a weekend
    # if the 15th is a weekend, the Friday before must be the 13th (Sunday, the 15th) or 14th (Saturday, the 15th)
    dates.rrule(rrule.rrule(rrule.MONTHLY, bymonthday=(13, 14), byweekday=(rrule.FR),
        dtstart=args.previous_period, until=args.date))

    # the last weekday of the month
    dates.rrule(rrule.rrule(rrule.MONTHLY, bysetpos=-1, byweekday=(rrule.MO, rrule.TU, rrule.WE, rrule.TH, rrule.FR),
        dtstart=args.previous_period, until=args.date))

    return dates

def get_annually_rrule(args):
    """Create a recurrence rule for pay periods between args.today and args.date, starting on args.previous_period, where a period is one year."""
    dates = rrule.rruleset()

    # January 1st, if it's a weekday
    dates.rrule(rrule.rrule(rrule.YEARLY, bymonth=1, bymonthday=1, byweekday=(rrule.MO, rrule.TU, rrule.WE, rrule.TH, rrule.FR),
        dtstart=args.previous_period, until=args.date))

    # the Monday after the 1st, if the 1st is a weekend
    # if the 1st is a weekend, the Monday after must be the 2nd (Sunday, the 1st) or 3rd (Saturday, the 1st)
    dates.rrule(rrule.rrule(rrule.YEARLY, bymonth=1, bymonthday=(2, 3), byweekday=(rrule.MO),
        dtstart=args.previous_period, until=args.date))

    return dates

    
rrules = {
    "biweekly": get_biweekly_rrule,
    "bimonthly": get_bimonthly_rrule,
    "annually": get_annually_rrule,
}

def get_dates_after(rrule: rrule.rrule, today: datetime.date) -> List[datetime.datetime]:
    """Get all dates in the recurrence rule after the given date."""
    return list(rrule.xafter(datetime.datetime.now().replace(year=today.year, month=today.month, day=today.day)))

def calculate_pto(args):
    """Calculate the number of periods between args.today and args.date, starting on args.previous_period, given the pay period type args.period."""
    print(f"Calculating {args.period} from {args.today} to {args.date} with period starting on {args.previous_period}")
    
    dates = rrules[args.period](args)

    # only include occurrences after today
    dates = get_dates_after(dates, args.today)

    accumulated_pto = accumulate_pto(args, dates)

    new_years = get_dates_after(get_annually_rrule(args), args.today)
    if len(new_years) > 0:
        additional_hours = args.floating_holidays * 8
        accumulated_pto += additional_hours
        if args.verbose:
            print(f"Adding {additional_hours:0.2f} floating holidays ({args.floating_holidays:0.2f} days) for the {new_years[-1].date()} ({new_years[-1]:%A}), the first business day after New Years Day.")

    return accumulated_pto
    
def get_default_previous_period(args) -> datetime.date:
    today: datetime.date = args.today
    if args.previous_period is not None:
        return args.previous_period
    elif args.period == "biweekly":
        # the Friday before args.today, or today if it's Friday
        return today + relativedelta.relativedelta(weekday=relativedelta.FR(-1))
    elif args.period == "bimonthly":
        # previous 15th or last day of the month (or preceding Friday, if on a weekend)
        months = 0
        day = 31
        candidate = today + relativedelta.relativedelta(day=day)
        while candidate > today:
            candidate = today + relativedelta.relativedelta(day=day, months=months)
            if candidate.weekday() in (5, 6):
                candidate += relativedelta.relativedelta(weekday=relativedelta.FR(-1))

            if day == 31:
                day = 15
            else:
                day = 31
                months -= 1

        return candidate
    elif args.period == "annually":
        # previous January 1st (or following Monday, if on a weekend)
        candidate = today + relativedelta.relativedelta(month=1, day=1)
        if candidate.weekday() in (5, 6):
            # 1st is on a weekend, find the next Monday
            candidate += relativedelta.relativedelta(weekday=relativedelta.MO)

        return candidate
    else:
        return datetime.date.today()


def fromisoformat(date: str) -> datetime.date:
    """
    Parse a date in YYYY-MM-DD format.
    
    This is a workaround for versions before Python 3.7, which don't have datetime.date.fromisoformat.
    """
    return datetime.datetime.strptime(date, "%Y-%m-%d").date()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
        description="Calculates PTO (Paid Time Off) based on a fixed period and accrual rate.",
        epilog="""

Accrual periods:
- Biweekly accrues every two weeks, starting from the previous Friday by default.
- Bimonthly accrues twice a month, starting from the previous 15th or last day of the month. If this date is on a weekend, the preceding Friday is used instead.
- Annually accrues once per year, starting from January 1st. If January 1st is on a weekend, the following Monday is used instead.
"""
    )

    parser.add_argument("period", help="Length of time where hours are accrued.", choices=rrules.keys())
    parser.add_argument("rate", help="Number of hours accrued per period", type=float)
    parser.add_argument("date", help="Target date to determine hours accrued", type=fromisoformat)
    parser.add_argument("--current-hours", help="Hours currently accured", type=float, default=0.0)
    parser.add_argument("--today", help="The starting date", type=fromisoformat, default=datetime.date.today())
    parser.add_argument("--previous-period", help="The end of the previous period, when hours were last accrued.",
        type=fromisoformat, default=None)

    parser.add_argument("--floating-holidays", help="Additional days of vacation that accrue instantly on January 1st and do not roll over.",
        default=0, type=int)
    
    parser.add_argument("--days", help="Display days of PTO", action="store_true")
    parser.add_argument("-v", "--verbose", help="Enable verbose output", action="store_true")

    args = parser.parse_known_args()[0]

    parser.set_defaults(previous_period=get_default_previous_period(args))

    args = parser.parse_args()

    if args.previous_period > args.today:
        parser.exit(1, "PREVIOUS_PERIOD should be before or equal to TODAY\n")

    if args.verbose:
        print(args)

    pto = calculate_pto(args)
    if args.days:
        pto /= 8.0

    pto_word = "days" if args.days else "hours"
    print(f"{pto_word.capitalize()} available on {args.date} ({args.date:%A}): {pto:.02f}")
